package main

import (
	"bufio"
	"bytes"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
)

var (
	serverOriginatedResponse     = regexp.MustCompile(`func[ ]*\(.(ServerOriginatedMessage_(([^ ]*)Response))\)[ ]*isServerOriginatedMessage_Submessage\(\).*`)
	clientOriginatedRequest      = regexp.MustCompile(`func[ ]*\(.(ClientOriginatedMessage_(([^ ]*)Request))\)[ ]*isClientOriginatedMessage_Submessage\(\).*`)
	serverOriginatedNotification = regexp.MustCompile(`[ ]*(([a-zA-Z0-9]+)(Notification|Changed))[ ]+\*(([a-zA-Z0-9]+)Notification)`)
)

type RequestResponse struct {
	Name            string
	RequestMessage  string
	ResponseMessage string
	Request         string
	Response        string
}

type Notification struct {
	Getter          string
	Notification    string
	APINotification string
	Interface       string
}

type Subscriber struct {
	RequireSession          bool
	RequestType             string
	NotificationRequestType string
	Kind                    string
	Type                    string
	Enum                    string
}

const (
	clientsCode = `
package iterm2

import (
	"errors"
	"github.com/tjamet/goterm2/api"
)

{{ range . }}
func (I *ITerm2) {{.Name}}(r *api.{{.Request}}) (*api.{{.Response}}, error) {
	m := &api.ClientOriginatedMessage{
		Id: I.NewID(),
		Submessage: &api.{{.RequestMessage}}{
			{{.Name}}Request: r,
		},
	}
	c, err := I.SendMessage(m)
	if err != nil {
		I.logger.Errorf("error sending {{.Request}} message ti iterm2:", err)
		return nil, err
	}
	if c != nil {
		a := <-c
		return a.Get{{.Name}}Response(), nil
	}
	I.logger.Errorf("unexpected error calling rpc for {{.Name}} no answer channel returned")
	return nil, errors.New("unexpected error")
}
{{ end }}
`
	notificationCode = `
package iterm2

import (
	"fmt"
	"github.com/tjamet/goterm2/api"
)

type (
{{ range . }}
	{{.Interface}} func(*api.{{ .APINotification }}) error
{{ end }}
)

type Notifier struct {
{{ range . }}
	{{ .Notification }}            []{{ .Interface }}
{{ end }}
}

func (I *ITerm2) RegisterNotifier(notifier interface{}) error {

	{{ range . }}
	if n, ok := notifier.({{ .Interface }}); ok {
		I.notifier.{{ .Notification }} = append(I.notifier.{{ .Notification }}, n)
		return nil
	}
	{{ end }}

	return fmt.Errorf("notifier does not match any existing notifier")
}


func (I *ITerm2) dispatchNotification(n *api.Notification) {
	{{ range . }}
	if n.Get{{ .Getter }}() != nil {
		for _, f := range I.notifier.{{ .Notification }} {
			go func(f {{ .Interface }}, n *api.Notification) {
				err := f(n.Get{{ .Getter }}())
				if err != nil {
					I.logger.Errorf("Failed to notify about {{ .Notification }}: %s", err)
				}
			}(f, n)
		}
	}
	{{ end }}
}
`

	subscriberCode = `
package iterm2

import (
	"github.com/tjamet/goterm2/api"
)

{{ range . }}
func (I *ITerm2) Subscribe{{ .Kind }}({{ if .RequireSession }} s *api.SessionSummary, {{ end }}{{ if .RequestType }}request *api.{{ .RequestType }}, {{end}}cbs ...func(*api.{{ .Type }}Notification) (error))(*api.NotificationResponse, error) {
	response, err := I.Notification(&api.NotificationRequest{
		Subscribe:        api.Bool(true),
		{{ if .RequireSession }}
		Session:          s.UniqueIdentifier,
		{{ end }}
		NotificationType: api.NotificationType_{{ .Enum }}.Enum(),
		{{ if .NotificationRequestType }}
		Arguments: &api.NotificationRequest_{{ .NotificationRequestType }}{
			{{ .NotificationRequestType }}: request,
		},
		{{ end }}
	})
	if err != nil {
		return nil, err
	}
	for _, cb := range cbs {
		err := I.RegisterNotifier({{ .Type }}Notifier(cb))
		if err != nil {
			return nil, err
		}
	}
	return response, err
}
{{ end }}
`
)

func (s *Subscriber) defaults() {
	if s.Kind == "" {
		s.Kind = s.Type
	}
	if s.NotificationRequestType == "" {
		s.NotificationRequestType = strings.Replace(s.RequestType, "RPC", "Rpc", -1)
	}
	if !strings.HasSuffix(s.Kind, "Changed") || !strings.HasSuffix(s.Kind, "Notification") || !strings.HasSuffix(s.Kind, "Notifications") {
		s.Kind = s.Kind + "Notifications"
	}
	if s.Enum == "" {
		s.Enum = "NOTIFY_ON_"
		for _, c := range strings.Replace(s.Type, "Changed", "Change", -1) {
			if c >= 'A' && c <= 'Z' && s.Enum[len(s.Enum)-1] != '_' {
				s.Enum += "_"
			}
			s.Enum += strings.ToUpper(string(c))
		}
	}
}

func genCode(tpl string, values interface{}, out string) {
	tmpl, err := template.New("code").Parse(tpl)
	if err != nil {
		panic(err)
	}

	fd, err := os.Create(out)
	if err != nil {
		panic(err)
	}
	fmt.Fprintln(fd, "// Code generated by generate/main.go. DO NOT EDIT.")
	fmt.Fprintln(fd, "// source: api/api.proto")
	err = tmpl.Execute(fd, values)
	if err != nil {
		panic(err)
	}
	fd.Close()
	cmd := exec.Command("gofmt", "-w", out)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		panic(err)
	}
}

func dlProto(out string) {

	resp, err := http.Get("https://raw.githubusercontent.com/gnachman/iTerm2/master/proto/api.proto")
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		panic(fmt.Errorf("unexpected http status code %d getting protocol", resp.StatusCode))
	}
	os.MkdirAll(filepath.Dir(out), 0700)
	fd, err := os.Create(out)
	if err != nil {
		panic(err)
	}
	b, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		panic(err)
	}
	_, err = fd.Write(bytes.ReplaceAll(b, []byte("package iterm2;"), []byte("package api;")))
	if err != nil {
		panic(err)
	}
}

func genProtobuf(proto string) {
	cmd := exec.Command("protoc", "--gogo_out=paths=source_relative:.", proto)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		panic(err)
	}
}

func main() {
	// set to false for offline code generation
	if true {
		dlProto("api/api.proto")
	}

	// set to false to skip protobuf generation
	if true {
		genProtobuf("api/api.proto")
	}
	fd, err := os.Open("api/api.pb.go")
	defer fd.Close()

	scanner := bufio.NewScanner(fd)
	if err != nil {
		panic(err)
	}
	notifications := []Notification{}
	requestResponsesMessages := map[string]*RequestResponse{}
	for scanner.Scan() {
		if s := serverOriginatedResponse.FindStringSubmatch(scanner.Text()); len(s) == 4 {
			name := s[3]
			object := strings.Replace(s[2], "RpcResult", "RPCResult", -1)
			message := s[1]
			if r, ok := requestResponsesMessages[name]; ok {
				r.ResponseMessage = message
				r.Response = object
			} else {
				requestResponsesMessages[name] = &RequestResponse{
					ResponseMessage: message,
					Response:        object,
					Name:            name,
				}
			}
		}
		if s := clientOriginatedRequest.FindStringSubmatch(scanner.Text()); len(s) == 4 {
			name := s[3]
			object := strings.Replace(s[2], "RpcResult", "RPCResult", -1)
			message := s[1]
			if r, ok := requestResponsesMessages[name]; ok {
				r.RequestMessage = message
				r.Request = object
			} else {
				requestResponsesMessages[name] = &RequestResponse{
					RequestMessage: message,
					Request:        object,
					Name:           name,
				}
			}
		}
		if s := serverOriginatedNotification.FindStringSubmatch(scanner.Text()); len(s) == 6 {
			notifications = append(notifications, Notification{
				Notification:    s[5],
				APINotification: s[4],
				Getter:          s[1],
				Interface:       s[5] + "Notifier",
			})
		}
	}
	for k, v := range requestResponsesMessages {
		if v.RequestMessage == "" {
			fmt.Printf("missing request message for key %s, removing it\n", k)
			delete(requestResponsesMessages, k)
		}
		if v.ResponseMessage == "" {
			fmt.Printf("missing response message for key %s, removing it\n", k)
			delete(requestResponsesMessages, k)
		}
	}
	if err := scanner.Err(); err != nil {
		panic(err)
	}
	knownSubscribers := []*Subscriber{
		&Subscriber{RequireSession: true, Kind: "PromptMonitor", Type: "Prompt", RequestType: "PromptMonitorRequest"},
		&Subscriber{RequireSession: true, Type: "ScreenUpdate"},
		// deprecated Subscriber{RequireSession: true, Kind: "", Type: "", Enum: "NOTIFY_ON_LOCATION_CHANGE"},
		&Subscriber{RequireSession: true, Type: "CustomEscapeSequence"},
		&Subscriber{RequireSession: true, Type: "VariableChanged", RequestType: "VariableMonitorRequest"},
		&Subscriber{RequireSession: true, Kind: "KeystrokeFilter", Type: "Keystroke", Enum: "KEYSTROKE_FILTER", RequestType: "KeystrokeFilterRequest"},
		// TODO: *NotificationRequest_KeystrokeMonitorRequest

		&Subscriber{RequireSession: false, Type: "NewSession"},
		&Subscriber{RequireSession: false, Type: "TerminateSession"},
		&Subscriber{RequireSession: false, Type: "LayoutChanged"},
		&Subscriber{RequireSession: false, Type: "FocusChanged"},
		&Subscriber{RequireSession: false, Type: "ServerOriginatedRPC", RequestType: "RPCRegistrationRequest", Enum: "NOTIFY_ON_SERVER_ORIGINATED_RPC"},
		&Subscriber{RequireSession: false, Type: "BroadcastDomainsChanged", Enum: "NOTIFY_ON_BROADCAST_CHANGE"},
		&Subscriber{RequireSession: false, Type: "ProfileChanged", RequestType: "ProfileChangeRequest"},
	}
	for _, s := range knownSubscribers {
		s.defaults()
	}
	genCode(clientsCode, requestResponsesMessages, "zzz_clients.go")
	genCode(notificationCode, notifications, "zzz_notification.go")
	genCode(subscriberCode, knownSubscribers, "zzz_subscribers.go")
}
