package main

import (
	"bufio"
	"bytes"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"os/exec"
	"regexp"
	"strings"
	"text/template"
)

var (
	serverOriginatedResponse = regexp.MustCompile(`func[ ]*\(.(ServerOriginatedMessage_(([^ ]*)Response))\)[ ]*isServerOriginatedMessage_Submessage\(\).*`)
	clientOriginatedRequest  = regexp.MustCompile(`func[ ]*\(.(ClientOriginatedMessage_(([^ ]*)Request))\)[ ]*isClientOriginatedMessage_Submessage\(\).*`)
)

type RequestResponse struct {
	Name            string
	RequestMessage  string
	ResponseMessage string
	Request         string
	Response        string
}

const code = `
package iterm2

import (
	"errors"
	"github.com/tjamet/goterm2/api"
)

{{ range . }}
func (I *ITerm2) {{.Name}}(r *api.{{.Request}}) (*api.{{.Response}}, error) {
	m := &api.ClientOriginatedMessage{
		Id: I.NewID(),
		Submessage: &api.{{.RequestMessage}}{
			{{.Name}}Request: r,
		},
	}
	c, err := I.SendMessage(m)
	if err != nil {
		I.logger.Errorf("error sending {{.Request}} message ti iterm2:", err)
		return nil, err
	}
	if c != nil {
		a := <-c
		return a.Get{{.Name}}Response(), nil
	}
	I.logger.Errorf("unexpected error calling rpc for {{.Name}} no answer channel returned")
	return nil, errors.New("unexpected error")
}
{{ end }}
`

func main() {
	tmpl, err := template.New("code").Parse(code)
	if err != nil {
		panic(err)
	}

	resp, err := http.Get("https://raw.githubusercontent.com/gnachman/iTerm2/master/proto/api.proto")
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		panic(fmt.Errorf("unexpected http status code %d getting protocol", resp.StatusCode))
	}
	os.MkdirAll("api", 0700)
	fd, err := os.Create("api/api.proto")
	if err != nil {
		panic(err)
	}
	b, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		panic(err)
	}
	_, err = fd.Write(bytes.ReplaceAll(b, []byte("package iterm2;"), []byte("package api;")))
	if err != nil {
		panic(err)
	}
	cmd := exec.Command("protoc", "--gogo_out=paths=source_relative:.", "api/api.proto")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		panic(err)
	}
	fd, err = os.Open("api/api.pb.go")
	defer fd.Close()

	scanner := bufio.NewScanner(fd)
	if err != nil {
		panic(err)
	}
	requestResponsesMessages := map[string]*RequestResponse{}
	for scanner.Scan() {
		if s := serverOriginatedResponse.FindStringSubmatch(scanner.Text()); len(s) == 4 {
			name := s[3]
			object := strings.Replace(s[2], "RpcResult", "RPCResult", -1)
			message := s[1]
			if r, ok := requestResponsesMessages[name]; ok {
				r.ResponseMessage = message
				r.Response = object
			} else {
				requestResponsesMessages[name] = &RequestResponse{
					ResponseMessage: message,
					Response:        object,
					Name:            name,
				}
			}
		}
		if s := clientOriginatedRequest.FindStringSubmatch(scanner.Text()); len(s) == 4 {
			name := s[3]
			object := strings.Replace(s[2], "RpcResult", "RPCResult", -1)
			message := s[1]
			if r, ok := requestResponsesMessages[name]; ok {
				r.RequestMessage = message
				r.Request = object
			} else {
				requestResponsesMessages[name] = &RequestResponse{
					RequestMessage: message,
					Request:        object,
					Name:           name,
				}
			}
		}
	}
	if err := scanner.Err(); err != nil {
		panic(err)
	}
	fd, err = os.Create("generated.go")
	if err != nil {
		panic(err)
	}
	fmt.Fprintln(fd, "// Code generated by generate/main.go. DO NOT EDIT.")
	fmt.Fprintln(fd, "// source: api/api.proto")
	err = tmpl.Execute(fd, requestResponsesMessages)
	if err != nil {
		panic(err)
	}
	fd.Close()
	cmd = exec.Command("gofmt", "-w", "generated.go")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		panic(err)
	}
}
